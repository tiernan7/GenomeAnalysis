Assignment: GS 540 HW3
Name: Tiernan Kennedy
Email: tiernan7@cs.washington.edu
Language: Python
Runtime: 3.4 min

Nucleotide Histogram:
A=914836
C=486187
G=475631
T=920846
N=600

Background Frequency:
A=0.3281
C=0.1719
G=0.1719
T=0.3281

Count Matrix:
-10 1050 234 790 654 
-9 950 229 922 627 
-8 896 245 902 685 
-7 942 196 740 850 
-6 1054 264 605 805 
-5 1129 240 457 902 
-4 1138 324 406 860 
-3 1177 292 501 758 
-2 1167 278 318 965 
-1 926 292 281 1229 
0 2308 0 239 181 
1 0 0 0 2728 
2 0 0 2728 0 
3 1110 433 683 502 
4 913 665 417 733 
5 1161 300 321 946 
6 1333 312 613 470 
7 1134 430 389 775 
8 1084 314 314 1016 
9 1233 274 612 609 
10 1083 385 335 925 

Frequency Matrix:
-10 0.3849 0.0858 0.2896 0.2397 
-9 0.3482 0.0839 0.3380 0.2298 
-8 0.3284 0.0898 0.3306 0.2511 
-7 0.3453 0.0718 0.2713 0.3116 
-6 0.3864 0.0968 0.2218 0.2951 
-5 0.4139 0.0880 0.1675 0.3306 
-4 0.4172 0.1188 0.1488 0.3152 
-3 0.4315 0.1070 0.1837 0.2779 
-2 0.4278 0.1019 0.1166 0.3537 
-1 0.3394 0.1070 0.1030 0.4505 
0 0.8460 0.0000 0.0876 0.0663 
1 0.0000 0.0000 0.0000 1.0000 
2 0.0000 0.0000 1.0000 0.0000 
3 0.4069 0.1587 0.2504 0.1840 
4 0.3347 0.2438 0.1529 0.2687 
5 0.4256 0.1100 0.1177 0.3468 
6 0.4886 0.1144 0.2247 0.1723 
7 0.4157 0.1576 0.1426 0.2841 
8 0.3974 0.1151 0.1151 0.3724 
9 0.4520 0.1004 0.2243 0.2232 
10 0.3970 0.1411 0.1228 0.3391 

Weight Matrix:
-10 0.2304 -1.0030 0.7524 -0.4527 
-9 0.0860 -1.0341 0.9753 -0.5135 
-8 0.0015 -0.9367 0.9437 -0.3858 
-7 0.0738 -1.2586 0.6581 -0.0745 
-6 0.2359 -0.8289 0.3675 -0.1530 
-5 0.3350 -0.9664 -0.0373 0.0112 
-4 0.3465 -0.5335 -0.2080 -0.0576 
-3 0.3951 -0.6835 0.0953 -0.2398 
-2 0.3828 -0.7544 -0.5604 0.1086 
-1 0.0491 -0.6835 -0.7389 0.4575 
0 1.3666 -99.0000 -0.9725 -2.3060 
1 -99.0000 -99.0000 -99.0000 1.6078 
2 -99.0000 -99.0000 2.5403 -99.0000 
3 0.3105 -0.1151 0.5424 -0.8343 
4 0.0287 0.5039 -0.1694 -0.2881 
5 0.3753 -0.6445 -0.5469 0.0799 
6 0.5747 -0.5879 0.3864 -0.9293 
7 0.3414 -0.1251 -0.2697 -0.2078 
8 0.2763 -0.5787 -0.5787 0.1829 
9 0.4622 -0.7753 0.3841 -0.5555 
10 0.2750 -0.2846 -0.4853 0.0475 

Max score: 14.4796545659

Score Histogram CDS:
-3 2
-2 10
-1 12
0 64
1 82
2 138
3 221
4 237
5 379
6 433
7 421
8 283
9 226
10 123
11 55
12 42

Score Histogram All:
-9 3
-8 33
-7 117
-6 571
-5 1964
-4 5306
-3 11270
-2 18975
-1 27161
0 34748
1 36118
2 35760
3 32274
4 27030
5 19682
6 12814
7 7592
8 3531
9 1165
10 408
11 114
12 48
lt-50 5319476

Position List:
488 1 10.9094
1972 1 10.8086
9184 1 11.0282
16315 1 10.8428
25863 0 10.2488
32239 0 10.0247
42300 1 11.0931
42618 1 10.9816
45573 1 10.9917
45696 1 10.1578
50642 1 11.2022
52705 0 10.2214
56893 1 10.9068
83755 1 11.3238
98590 1 10.5610
104334 0 10.6315
122310 1 10.0736
122613 1 11.7212
139071 0 10.7771
164743 1 10.1734
170628 1 10.9198
201930 1 10.0012
204731 1 10.3260
205496 1 10.0103
205999 1 10.0829
208172 0 10.5195
210382 1 10.6818
216449 0 10.8455
226143 0 10.3558
244670 0 11.0475
252715 1 10.0275
268501 0 10.6420
274143 1 10.7771
276593 1 11.4434
290717 0 10.2124
302699 0 11.4566
310037 1 10.1455
311751 0 10.6594
327311 1 10.5565
333364 0 11.0016
345341 0 10.9081
345624 0 10.0891
357798 1 10.1017
359134 1 11.4783
363303 0 10.1087
364450 1 10.2014
365327 1 10.1954
375915 0 10.2332
385338 1 10.0394
385988 1 10.3668
387043 1 10.7226
393844 1 10.3603
393893 1 10.2051
394982 0 10.1455
396951 0 10.1087
398945 1 11.0557
399650 0 10.4835
401408 1 11.3526
408804 0 10.0394
421522 1 10.9480
424728 1 11.0219
428064 1 10.1020
429680 1 10.2201
442070 1 10.2576
455598 1 10.5762
469374 1 11.3526
476770 0 10.0394
498800 1 10.1017
504402 0 11.8423
549579 0 10.0830
569926 1 10.0203
570804 1 11.3767
579191 0 10.7771
580889 1 10.7508
584746 0 10.3624
593212 1 10.2153
595303 1 10.4979
602806 1 10.0814
611782 1 10.9364
617434 0 10.5500
620723 1 10.8507
662546 0 12.0314
662860 0 10.1734
686569 1 10.1017
695579 1 10.0442
709313 1 10.1455
713409 0 11.1044
714172 0 10.0829
714675 0 10.0103
719354 0 11.5709
721312 0 10.6123
733142 0 11.4566
740480 1 10.1455
742194 0 10.6594
747963 1 10.0394
749224 1 11.5125
750044 1 10.3056
750838 1 11.3355
754474 1 10.3353
754920 1 10.7020
759564 1 10.2750
770190 1 10.0388
770866 1 10.9613
804617 1 10.1850
806626 0 10.3121
824849 1 10.0394
832949 1 10.3353
833395 1 10.7020
835621 1 10.2750
841542 1 10.8973
841935 1 11.0510
845623 1 11.0878
845945 1 10.9613
857683 0 10.0650
878758 1 11.6990
881634 1 10.0303
882871 0 10.2105
884803 1 10.5291
893766 1 10.2696
894366 1 11.0016
895265 1 10.3125
899787 1 10.0394
907124 1 10.4155
913522 1 10.1979
923468 1 10.2696
924068 1 11.0016
931846 1 10.0757
933024 1 10.0468
953156 1 10.1657
963844 1 10.5210
966642 0 10.6690
976549 0 10.0394
988092 0 10.4328
991185 1 10.4847
995303 0 10.1720
1002822 1 10.1661
1009505 0 10.2709
1011049 1 12.4754
1014667 1 10.6734
1016426 1 10.1538
1028921 0 10.0992
1084142 1 10.8455
1085977 0 10.5806
1088367 1 10.1017
1089710 1 11.4783
1104358 0 10.4720
1118655 1 10.1734
1121874 0 10.9403
1144487 0 10.0394
1150080 0 11.0016
1158426 1 10.0394
1159715 1 11.0016
1177218 1 10.8455
1180008 1 10.1455
1193114 0 11.4783
1196847 1 10.5806
1205045 1 10.3558
1214739 1 10.8455
1220806 0 10.6818
1223016 1 10.5195
1225189 0 10.0829
1225692 0 10.0103
1226457 0 10.3260
1229258 0 10.0012
1260560 0 10.9198
1266445 0 10.1734
1292117 1 10.7771
1308575 0 11.7212
1308878 0 10.0736
1326854 1 10.6315
1332598 0 10.5610
1337775 1 10.5610
1343519 0 10.6315
1361495 1 10.0736
1361798 1 11.7212
1378891 0 10.0394
1390434 0 10.4328
1393527 1 10.4847
1397645 0 10.1720
1405164 1 10.1661
1411847 0 10.2709
1413391 1 12.4754
1417009 1 10.6734
1418768 1 10.1538
1431263 0 10.0992
1491736 0 10.1997
1505013 1 10.3136
1513549 0 10.5195
1515759 1 10.6818
1530821 1 10.7411
1541318 0 10.1455
1544033 1 10.1017
1554019 1 10.6690
1556817 0 10.5210
1567505 0 10.1657
1587637 0 10.0468
1588815 0 10.0757
1596593 0 11.0016
1597193 0 10.2696
1607139 0 10.1979
1613537 0 10.4155
1620874 0 10.0394
1625396 0 10.3125
1626295 0 11.0016
1626895 0 10.2696
1635858 0 10.5291
1637790 1 10.2105
1639027 0 10.0303
1641903 0 11.6990
1662978 1 10.0650
1674716 0 10.9613
1675038 0 11.0878
1678726 0 11.0510
1679119 0 10.8973
1685040 0 10.2750
1687266 0 10.7020
1687712 0 10.3353
1691348 0 11.3355
1692142 0 10.3056
1692962 0 11.5125
1694223 0 10.0394
1699992 1 10.6594
1701706 0 10.1455
1709044 1 11.4566
1720874 1 10.6123
1722832 1 11.5709
1727511 1 10.0103
1728014 1 10.0829
1728777 1 11.1044
1732873 0 10.1455
1746607 0 10.0442
1779326 1 10.1734
1779640 1 12.0314
1821463 0 10.8507
1824752 1 10.5500
1830404 0 10.9364
1839380 0 10.0814
1846883 0 10.4979
1848974 0 10.2153
1857440 1 10.3624
1861297 0 10.7508
1862995 1 10.7771
1871382 0 11.3767
1872260 0 10.0203
1892607 1 10.0830
1938387 0 10.0394
1949930 0 10.4328
1953023 1 10.4847
1957141 0 10.1720
1964660 1 10.1661
1971343 0 10.2709
1972887 1 12.4754
1976505 1 10.6734
1978264 1 10.1538
1990759 0 10.0992
2045980 1 10.8455
2047815 0 10.5806
2050205 1 10.1017
2051548 1 11.4783
2064654 0 10.1455
2067444 0 10.8455
2084947 0 11.0016
2086236 0 10.0394
2094582 1 11.0016
2100175 1 10.0394
2122788 1 10.9403
2126007 0 10.1734
2140304 1 10.4720
2148947 1 10.5011
2155717 1 10.8455
2157311 1 10.5323
2170102 0 10.1800
2170366 0 10.3957
2195958 0 11.0016
2200182 1 11.5943
2215389 1 10.0811
2227995 1 11.0016
2240091 1 10.3588
2253281 1 10.0394
2255029 1 10.8455
2267706 1 10.4267
2277966 1 10.8114
2283020 1 10.3353
2283466 1 10.7020
2285692 1 10.2750
2291613 1 10.8973
2292006 1 11.0510
2295694 1 11.0878
2296016 1 10.9613
2307754 0 10.0650
2328829 1 11.6990
2331705 1 10.0303
2332942 0 10.2105
2334874 1 10.5291
2343837 1 10.2696
2344437 1 11.0016
2345336 1 10.3125
2349858 1 10.0394
2357195 1 10.4155
2363593 1 10.1979
2373539 1 10.2696
2374139 1 11.0016
2381917 1 10.0757
2383095 1 10.0468
2403227 1 10.1657
2413915 1 10.5210
2416713 0 10.6690
2429414 1 10.1455
2439911 0 10.7411
2462358 0 10.7771
2465137 0 11.0253
2465393 1 10.7625
2465952 1 10.1552
2484595 0 10.5762
2506797 1 10.9480
2510003 1 11.0219
2513339 1 10.1020
2514955 1 10.2201
2527345 1 10.2576
2546730 0 10.2332
2558189 1 10.3603
2558238 1 10.2051
2559327 0 10.1455
2565234 1 10.3439
2567095 0 10.7180
2576863 0 10.0750
2580525 1 10.2282
2583618 0 10.1520
2602488 0 10.0394
2614031 0 10.4328
2617124 1 10.4847
2621242 0 10.1720
2628761 1 10.1661
2635444 0 10.2709
2636988 1 12.4754
2640606 1 10.6734
2642365 1 10.1538
2654860 0 10.0992
2710081 1 10.8455
2711916 0 10.5806
2714306 1 10.1017
2715649 1 11.4783
2728755 0 10.1455
2731545 0 10.8455
2749048 0 11.0016
2750337 0 10.0394
2758683 1 11.0016
2764276 1 10.0394
2786889 1 10.9403
2790108 0 10.1734

Program:
from Bio import SeqIO
import re
import numpy as np
import math
import os
import timeit

#A function writes certain program checks to a log file
def log(text):
    with open("log","a") as logfile:
        logfile.write(text)


start = timeit.default_timer()
np.set_printoptions(suppress=True)

#  record = SeqIO.read("Armadillidium_vulgare_contig1.gbff","genbank")
                         
f = "Armadillidium_vulgare_contig1.gbff" #filename
o = "TIERNAN_KENNEDY_HOMEWORK3.txt" #output filename

#Makes it easier to develope when writing in append mode
if os.path.exists(o):
    os.remove(o)

#Using biopython to extract the sequence from the genbank file
record = SeqIO.read(f,"genbank")
seq = str(record.seq)


#Counts the number of occurences of a character in a string
def countNucleotide(seq, base):
    count = 0
    for i in range(len(seq)):
        if seq[i] == base:
            count += 1
    return count

log("The are are " + str(countNucleotide("TGATGGTATGNNTGATGK",'G')) + " Gs in TGATGGTATGNNTGATGK" + '\n'
)

#The four bases in DNA
bases = ['A', 'C', 'G', 'T']

#A dictionary for finding complements
baseDict = {'A' : 'T',
            'C' : 'G',
            'T' : 'A',
            'G' : 'C',
            'N' : 'N'}

#A hashing of the characters to ints
baseToNum = {'A' : 0,
             'C' : 1,
             'G' : 2,
             'T' : 3}

#Returns the reverse complement of a string
def reverseComplement(s):
    return "".join(np.flip([baseDict[char] for char in s]))

log("The reverse complement of T is: " + str(reverseComplement('T')) + '\n'
    )


#Prints the nucleotide counts and frequencies
def getNucleotideHistogram(sequence):
    nucleotideCounts = np.zeros(5)
    for base in bases:
        nucleotideCounts[baseToNum[base]] = countNucleotide(sequence, base)
    s = sum(nucleotideCounts)
    l = len(sequence)
    returnString = ""
    returnString += "Nucleotide Histogram:" + '\n'
    returnString += "A=" + str(int(nucleotideCounts[0])) + '\n'
    returnString += "C=" + str(int(nucleotideCounts[1])) + '\n'
    returnString += "G=" + str(int(nucleotideCounts[2])) + '\n'
    returnString += "T=" + str(int(nucleotideCounts[3])) + '\n'
    returnString += "N=" + str(int(l - s)) + '\n'
    returnString += '\n'
    returnString += "Background Frequency:" + '\n'
    returnString += "A=" + ("%.4f" % round(float((nucleotideCounts[0] + nucleotideCounts[3])) / (2*s), 4)) + '\n'
    returnString += "C=" + ("%.4f" % round(float((nucleotideCounts[1]+nucleotideCounts[2] )) / (2*s), 4)) + '\n'
    returnString += "G=" + ("%.4f" % round(float((nucleotideCounts[2]+nucleotideCounts[1])) / (2*s), 4)) + '\n'
    returnString += "T=" + ("%.4f" % round(float((nucleotideCounts[3] +nucleotideCounts[0]))/ (2*s), 4)) + '\n'

    return returnString

log("The nucleotide histogram for ATGCTCANNNNNNNKJ is: " + str(getNucleotideHistogram('ATGCTCANNNNNNNKJ')) + '\n'
)

#Opening the genbank file and reading it into a list of lines
file = open(f, "r")
allLines = file.readlines()
file.close()


#Removes all empty characters from a string
def removeEmptyCharacters(array):
    return [x for x in array if x != '']

log("The following text is on one line: " + str(removeEmptyCharacters("Line 1 \n Line 2")) + '\n'
)



#Takes in an array of words from a line of a genbank file
#Returns True if the any of the words contain an ambiguous coordinate signature
def badCoordinates(wordsArray):
    return (re.search("<+|>+", wordsArray[-1]) != None)

log("It is " + str(badCoordinates(["10002000>303"])) + " that 10002000>303 is a bad coordinate" + '\n'
)

startSites = []

#Takes in a CDS description containing a join statment
#Returns an ordered list of the bases around the start of the CDS
def brokenIntervals(intervals, comp): #Intervals is a list of each integer within a join statement in the orer of appearance, records whether or not the complemet
    global startSites
    if not(comp): #Handles the case where the join intervals are the on forward strand
        returnIterator = [] 
        start = int(intervals[0]) - 1 #-1 adjustment tp translate genbank coordinates to array coordinates
        startSites += [int(start + 1)]
        returnIterator = np.arange(start- 10 , start + 1) #generates the sites of the ten bases before and upto the start
        ranges = [int(i) - 1 for i in intervals] #converts the entire list of intervals to array coordinates
        forwardLength = [] 
        ind = 1#distance from start site of current interval
        r = 0#index of which set of intervals to consider
        start = ranges[0]
        while len(forwardLength) < 10: #Generates the ten bases after the start
            if (start + ind > ranges[r+1]): #If you're pointing to an adress out of the current interval...
                r += 2
                start = ranges[r]#...start at the next site
                ind = 0#Reset the distance of the pointer from the current start site
            forwardLength += [start + ind]#Add the array coordinates of that site in the interval to the output array
            ind+=1
        returnIterator = np.append(returnIterator, forwardLength)#merge the two halves of the sequence
        return returnIterator

    else:#Handles the case where the join intervals are on the reverse strand     
        returnIterator = []
        a = np.flip([int(i) - 1 for i in intervals])#Reverses the list of coordinates to account for navigating the interval in reverse and subtraction to convert to ar#ray coordinates
        start = int(a[0])#start at the array coordinate of the last element in forward strand on the coding interval
        startSites += [int(start + 1)]
        returnIterator = np.flip(np.arange(start , start + 11))#generates the coordinat running from 11 before the start site to the start site
        forwardLength = []
        ind = -1#The distcance from the start site
        r = 0#The index of the interval in question
        while len(forwardLength) < 10:#While you havent added enough stuff
            if (start + ind < a[r+1]):#check to see if youre going to leave the interval
                r += 2 
                start = a[r] #if so go to the next interval
                ind = 0
            forwardLength += [start + ind]#Add the array coordinates of the site to the sequence
            ind+= -1
        returnIterator = np.append(returnIterator, forwardLength)#Add the second half of the sequence to the first
        return returnIterator

log("The array sites for complement(join(1..10,11..30)) is " + str(brokenIntervals([1,10,11,30], True)) + '\n'
)

#Returns the column of an array
def column(arr, i):
    col = []
    for st in arr:
        col += [st[i]]
    return col
       

log("The column second column of [[1,2,3],[4,5,6],[7,8,9]] is "  + str(column([[1,2,3],[4,5,6],[7,8,9]],1)) + '\n'
)



#Takes a string text from a CDS description, but not multiple lines
def positionToChars(positionString):
    global startSites
    if (re.search('complement', positionString) == None):# if there are no complement tags
        if (re.search('join', positionString) == None): #and no join tags
            start = int(re.findall("\d+", positionString)[0]) - 1 #then start site is the first numeral in the position string minus 1 to convert to array coordinates
            startSites += [int(start + 1)]
            return [seq[i] for i in np.arange(start - 10, start + 11)]#and we can return the ten elements on either side
        else: #otherwise if there are no complement tags but there is a join statement
            intervals = re.findall("\d+", positionString)# convert the string to a flat list of position numeral for the brokenIntervals function
            return [seq[i] for i in brokenIntervals(intervals, False)] #Use the broken intervals helper function to find the list of coordinates
    else:#otherwise if there are complement tags
        if (re.search('join', positionString) == None):#but no join statements
            start = int(re.findall("\d+", positionString)[-1]) - 1 #start at the last numeral in the CDS description, and subtract 1 for array coordinates
            startSites += [int(start + 1)]
            return[baseDict[seq[i]] for i in np.flip( np.arange(start - 10, start + 11))]#return the reversed order of the ten elements around the start site

        else:# and if there are no join tags but the start is on the complementary strand
            intervals = re.findall("\d+", positionString)# get the list of numeraks in the CDS desription
            return [baseDict[seq[i]] for i in brokenIntervals(intervals, True)]#Use the broken intervals function to generates, which are reversed automatically by roken intervals
log("The characters for (1..10) is :" + str(positionToChars("(1..10)")) + '\n'
    )

#Takes in the text from any line containing CDS and extracts the portion of it containing the description and finds any overflow lines
positions = []
for i, lines in enumerate(allLines):
    cdsCheck = (re.search("CDS", lines) != None)#gets all lines containing "CDS"
    if cdsCheck and re.search('[0-9]',lines) != None:#but only takes those with numerals (To avoid the case when the 'CDS' protein sequence is accidentally parsed)
        words = re.split("\s", lines) #Split the line into words
        words = removeEmptyCharacters(words)#and remove empty characters
        if (badCoordinates(words)):#check to see if there are any ambiguous start or end sites
            pass #and if so ignor these
        else: #If the coorinates are okay
            delete = False
            if (re.search("complement|join", words[-1]) != None and words[-1][-1] != ")"):#checks to see if there are any descs that run onto two lines
                ind = 1
                delete = False
                while words[-1][-1] != ")": #A loop that continues until the end of the description has been found, start by checking first line
                    words[-1] += allLines[i+ind].strip()#adds the next line of sequence
                    if re.search(">|<", allLines[i+ind]) != None:#and marks it in case there was a variable end position that wasnt caught in the first check
                        delete = True 
                    i+=1#Goes to the next line
            positions += [words[-1]]#Adds the full description to the position array
            if delete:
                positions.pop(-1)#Deletes the position if it was marked as such


backgroundCounts = np.zeros(4)
backgroundFrequencies = np.zeros(4)

#counts the number of nucleotides of A,T,C and G in the genbank sequence
for base in bases:
    backgroundCounts[baseToNum[base]] = countNucleotide(seq,base)

for b  in bases:#Converts the frequencies of nucleotides to their ratios 
    backgroundFrequencies[baseToNum[b]] = float(backgroundCounts[baseToNum[b]] + backgroundCounts[baseToNum[baseDict[b]]]) / (2* sum(backgroundCounts)) #nucleotide counts are averaged with the sum of their complement to account for reverse stran


allSequences = [positionToChars(pos) for pos in positions]#Creating an array of windows of ten nucleotides on either side of each CDS feature

markedSites = ["".join(s) for s in allSequences]


siteCounts = np.zeros((21,4))
siteFrequencies = np.zeros((21,4))
weightMatrix = np.zeros((21,4))


#counts the number of nucleotides at each position in each sequence
for i in range(len(siteCounts)):
    for base in bases:
        siteCounts[i][baseToNum[base]] = countNucleotide(column(allSequences, i),base )

#converts the counts from above to frequencies
for i in range(len(siteFrequencies)):
    s = sum(siteCounts[i])
    for j in range(4):
           siteFrequencies[i][j] = siteCounts[i][j] / s

#Perform a small correction and calculate weights for each base at each site
for i in range(len(siteFrequencies)):
    for base in bases:
        if siteFrequencies[i][baseToNum[base]] == 0:
            weightMatrix[i][baseToNum[base]] = -99.0
        else:
            weightMatrix[i][baseToNum[base]] = np.log2(siteFrequencies[i][baseToNum[base]] / backgroundFrequencies[baseToNum[base]])


#A function to score a sequence of 21 nucleotides against the weight matrix
def scoreSequence(s):
    assert len(s) == 21, "The sequence: " + str(s) + " does not have length 21"
    score = 0
    for i,char in enumerate(s):
        if char in bases:
            score += weightMatrix[i][baseToNum[char]] #Compute the dot product of the sequence against the weight matrix
        else: 
            score += 0
    return score

log("The score of NNNNNNNNNNNNNNNNNNNNA is " + str(scoreSequence("NNNNNNNNNNNNNNNNNNNNA")) + '\n'
    )

#A function that returns a histrogram of the scores of each CDS site as a string
def scoreHistogramCDS():
    returnString = ""
    returnString += "Score Histogram CDS:" + '\n'
    scores = []

    for s in allSequences:#For each sequence we collected from the CDS sites, we add its score, rounded down, to a list
        scores += [math.floor(scoreSequence(s))]


    for i in range(-50,100):
        count = len([j for j in scores if j == i]) #count the number of each score in the list and..
        if count != 0:
            returnString += str(i) + " " + str(count) + '\n' #Add that row to the histogram if the bin is nonempty

    if (len([i for i in scores if i < -50]) != 0):
        returnString += "lt-50 " + str(len([i for i in scores if i < -50])) + '\n'
      
    returnString += '\n'
    return returnString

#a function that computes outputs the histogram of scores for each sequence in the complex and also returns the list of high scorers
def scoreAll():
    returnString = ""
    returnString += "Score Histogram All:" + '\n'
    scores =[]
    l = len(seq) 
    stretches = [seq[i:i+21] for i in range(len(seq) - 20)]


    for i, s in enumerate(stretches):
        scores += [[scoreSequence(s), i + 1 + 10, 0]]
        scores += [[scoreSequence(reverseComplement(s)), i + 1 + 10, 1]]  


    for i in range(-50,100):
        count = len([j[0] for j in scores if math.floor(j[0]) == i])
        if count != 0:
            returnString += str(i) + " " + str(count) + '\n'

    returnString += "lt-50 " + str( len([math.floor(i[0]) for i in scores if math.floor(i[0]) < -50])) + '\n'
    returnString += '\n'

    returnString += "Position List:"
    matches = np.array([sc for sc in scores if (sc[0] >= 10 and int(sc[1]) not in startSites)])
    sortedMatches = matches[np.argsort(column(matches,1))]
    for m in sortedMatches:
        returnString += str(int(m[1])) + " " + str(int(m[2])) + " " + str("%.4f" % round(m[0], 4)) + '\n'
    returnString += '\n'

    return returnString

with  open(o, 'a') as file:
    file.write(getNucleotideHistogram(seq) + '\n')
    file.write('\n')

    file.write("Count Matrix:" + '\n')
    for i in range(len(siteCounts)):
        file.write(str(i-10) + " ")
        for j in range(4):
            file.write(str(round(siteCounts[i][j])) + " ")
        file.write('\n')
    file.write('\n')

    file.write("Frequency Matrix:" + '\n')
    for i in range(len(siteFrequencies)):
        file.write(str(i-10) + " ")
        for j in range(4):
            file.write(str("%.4f" % round(siteFrequencies[i][j],4)) + " ")
        file.write('\n')
    file.write('\n')

    file.write("Weight Matrix:" + '\n')
    for i in range(len(weightMatrix)):
        file.write(str(i-10) + " ")
        for j in range(4):
            file.write(str("%.4f" % round(weightMatrix[i][j],4)) + " ")
        file.write('\n')
    file.write('\n')

    file.write("Max score: " + str("%.10f" % round(sum([max(i) for i in weightMatrix]),10)) + '\n')
    file.write('\n')

    file.write(scoreHistogramCDS() + '\n')
    file.write('\n')
    
    file.write(scoreAll())
    file.write('\n')
    file.write("Program:" + '\n')

stop = timeit.default_timer()
print("Runtime: " + str(stop - start) + "s")



